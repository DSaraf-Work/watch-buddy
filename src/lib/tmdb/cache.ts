import { createClient } from '@/lib/supabase/server'
import { createServiceClient } from '@/lib/supabase/service'
import type { ContentData, TMDBMovie, TMDBTVShow, TMDBCredits, TMDBVideo } from './types'
import { tmdbClient, getYouTubeTrailerUrl } from './client'

/**
 * Get content from cache or fetch from TMDB
 */
export async function getContentById(
  tmdbId: number,
  contentType: 'movie' | 'series'
): Promise<ContentData | null> {
  const supabase = await createClient()

  // Try to get from cache first
  const { data: cached, error: cacheError } = await supabase
    .from('content')
    .select('*')
    .eq('tmdb_id', tmdbId)
    .eq('content_type', contentType)
    .single()

  // If found in cache and not too old (24 hours), return it
  if (cached && !cacheError) {
    const cacheAge = Date.now() - new Date(cached.updated_at).getTime()
    const maxAge = 24 * 60 * 60 * 1000 // 24 hours

    if (cacheAge < maxAge) {
      return transformCachedContent(cached)
    }
  }

  // Fetch from TMDB
  if (!tmdbClient) {
    throw new Error('TMDB client not initialized. Please set TMDB_API_KEY.')
  }

  try {
    let contentData: ContentData

    if (contentType === 'movie') {
      const movie = await tmdbClient.getMovie(tmdbId)
      const credits = await tmdbClient.getMovieCredits(tmdbId)
      const videos = await tmdbClient.getMovieVideos(tmdbId)
      contentData = transformMovieData(movie, credits, videos.results)
    } else {
      const tvShow = await tmdbClient.getTVShow(tmdbId)
      const credits = await tmdbClient.getTVCredits(tmdbId)
      const videos = await tmdbClient.getTVVideos(tmdbId)
      contentData = transformTVShowData(tvShow, credits, videos.results)
    }

    // Cache the data and get the ID
    const cachedId = await cacheContent(contentData)
    if (cachedId) {
      contentData.id = cachedId
    }

    return contentData
  } catch (error) {
    console.error('Error fetching content from TMDB:', error)
    return null
  }
}

/**
 * Cache content data in Supabase
 * Uses service role client to bypass RLS for caching operations
 */
async function cacheContent(content: ContentData): Promise<string | null> {
  const supabase = createServiceClient()

  const { data, error } = await supabase.from('content').upsert(
    {
      tmdb_id: content.tmdb_id,
      imdb_id: content.imdb_id,
      title: content.title,
      original_title: content.original_title,
      content_type: content.content_type,
      overview: content.overview,
      poster_path: content.poster_path,
      backdrop_path: content.backdrop_path,
      release_date: content.release_date,
      runtime: content.runtime,
      genres: content.genres,
      cast_data: content.cast_data,
      crew_data: content.crew_data,
      ratings: content.ratings,
      trailer_url: content.trailer_url,
      updated_at: new Date().toISOString(),
    },
    {
      onConflict: 'tmdb_id',
    }
  )
  .select('id')
  .single()

  if (error) {
    console.error('Error caching content:', error)
    return null
  }

  return data?.id || null
}

/**
 * Transform TMDB movie data to ContentData
 */
function transformMovieData(
  movie: TMDBMovie,
  credits: TMDBCredits,
  videos: TMDBVideo[]
): ContentData {
  return {
    id: '', // Will be generated by database
    tmdb_id: movie.id,
    imdb_id: movie.imdb_id || null,
    title: movie.title,
    original_title: movie.original_title,
    content_type: 'movie',
    overview: movie.overview,
    poster_path: movie.poster_path,
    backdrop_path: movie.backdrop_path,
    release_date: movie.release_date ? new Date(movie.release_date) : null,
    runtime: movie.runtime,
    genres: movie.genres,
    cast_data: credits.cast.slice(0, 20), // Top 20 cast members
    crew_data: credits.crew.filter((c) => ['Director', 'Writer', 'Producer'].includes(c.job)),
    ratings: {
      tmdb: movie.vote_average,
    },
    trailer_url: getYouTubeTrailerUrl(videos),
  }
}

/**
 * Transform TMDB TV show data to ContentData
 */
function transformTVShowData(
  tvShow: TMDBTVShow,
  credits: TMDBCredits,
  videos: TMDBVideo[]
): ContentData {
  return {
    id: '', // Will be generated by database
    tmdb_id: tvShow.id,
    imdb_id: null,
    title: tvShow.name,
    original_title: tvShow.original_name,
    content_type: 'series',
    overview: tvShow.overview,
    poster_path: tvShow.poster_path,
    backdrop_path: tvShow.backdrop_path,
    release_date: tvShow.first_air_date ? new Date(tvShow.first_air_date) : null,
    runtime: tvShow.episode_run_time?.[0] || null,
    genres: tvShow.genres,
    cast_data: credits.cast.slice(0, 20), // Top 20 cast members
    crew_data: credits.crew.filter((c) => ['Director', 'Writer', 'Producer', 'Creator'].includes(c.job)),
    ratings: {
      tmdb: tvShow.vote_average,
    },
    trailer_url: getYouTubeTrailerUrl(videos),
  }
}

/**
 * Transform cached content from database to ContentData
 */
function transformCachedContent(cached: any): ContentData {
  return {
    id: cached.id,
    tmdb_id: cached.tmdb_id,
    imdb_id: cached.imdb_id,
    title: cached.title,
    original_title: cached.original_title,
    content_type: cached.content_type,
    overview: cached.overview,
    poster_path: cached.poster_path,
    backdrop_path: cached.backdrop_path,
    release_date: cached.release_date ? new Date(cached.release_date) : null,
    runtime: cached.runtime,
    genres: cached.genres || [],
    cast_data: cached.cast_data || [],
    crew_data: cached.crew_data || [],
    ratings: cached.ratings || { tmdb: 0 },
    trailer_url: cached.trailer_url,
  }
}

